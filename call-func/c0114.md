---
title: "sequence matters in return 1"
date: 2020-06-27T03:09:30+66:00
draft: false
weight: 1240

---

##### This shows that the sequence of the return matters. In this demo, it returns a value to caller, the following change in callee to the same var will not be reflected to caller.

This is also an example to show that the return cmd returns the value instead of the pointer


### Demo








[source](https://github.com/upcmd/up/blob/master/tests/functests/c0114.yml)

##### Main task yaml file
```
    vars:
      tom: this is tom in global
      jerry: this is jerry in global
    tasks:
    - name: task
      desc: main entry
      task:
      - func: call
        desc: call subtask and exam the return value in following steps
        do: subtask1
      - func: cmd
        desc: |
          check value of tom
          in this case tom's value should come from subtask1
          tom's expected value:  tom created in subtask1
        do:
        - name: print
          cmd: 'in main task print3: {{.tom}}'
    - name: subtask1
      desc: subtask to test reg and return
      task:
      - func: cmd
        desc: check value of tom after it is registered in current task stack
        vars:
          john: john in sub_loop func1
        do:
        - name: reg
          desc: by default hitom is registered in to global context
          cmd:
            name: tom
            value: 'tom created in subtask1'
        - name: print
          cmd: 'in sub_loop print1: {{.tom}}'
      - func: cmd
        desc: check value of tom and it should be available in current stack
        vars:
          john: john in sub_loop func2
        do:
        - name: print
          cmd: 'in sub_loop print2: {{.tom}}'
        - name: return
          cmd:
          - tom
      - func: call
        desc: call subtask and exam the return value in following steps
        do: subtask2
    - name: subtask2
      desc: subtask to test reg and return
      task:
      - func: cmd
        desc: check value of tom after it is registered in current task stack
        vars:
          john: john in sub_loop func1
        do:
        - name: reg
          desc: by default hitom is registered in to global context
          cmd:
            name: tom
            value: 'tom2 created in subtask2'
        - name: print
          cmd: 'in sub_loop print1: {{.tom}}'
      - func: cmd
        desc: check value of tom and it should be available in current stack
        vars:
          john: john in sub_loop func2
        do:
        - name: print
          cmd: 'in sub_loop print2: {{.tom}}'
        - name: return
          cmd:
          - tom
    
```
##### Main log file
```
    loading [Config]:  ./tests/functests/upconfig.yml
    Main config:
                 Version -> 1.0.0
                  RefDir -> ./tests/functests
                 WorkDir -> cwd
              AbsWorkDir -> /up_project/up
                TaskFile -> c0114
                 Verbose -> vvv
              ModuleName -> cranky_franklin4
               ShellType -> /bin/sh
           MaxCallLayers -> 8
     MaxModuelCallLayers -> 256
    work dir: /up_project/up
    -exec task: task
    loading [Task]:  ./tests/functests/c0114
    module: [cranky_franklin4] instance id: [dev]
    Task1: [task ==> task: main entry ]
    -Step1: [: call subtask and exam the return value in following steps ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "tom": "this is tom in global",
      "jerry": "this is jerry in global"
    })
    
    =Task2: [task ==> subtask1: subtask to test reg and return ]
    --Step1: [: check value of tom after it is registered in current task stack ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "tom": "this is tom in global",
      "jerry": "this is jerry in global",
      "up_runtime_task_layer_number": 1,
      "john": "john in sub_loop func1"
    })
    
    ~~SubStep1: [reg: by default hitom is registered in to global context ]
    ~~SubStep2: [print:  ]
    in sub_loop print1: tom created in subtask1
    --Step2: [: check value of tom and it should be available in current stack ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "john": "john in sub_loop func2",
      "jerry": "this is jerry in global",
      "tom": "tom created in subtask1",
      "up_runtime_task_layer_number": 1
    })
    
    ~~SubStep1: [print:  ]
    in sub_loop print2: tom created in subtask1
    ~~SubStep2: [return:  ]
    --Step3: [: call subtask and exam the return value in following steps ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "up_runtime_task_layer_number": 1,
      "tom": "tom created in subtask1",
      "jerry": "this is jerry in global"
    })
    
    ==Task3: [task/subtask1 ==> subtask2: subtask to test reg and return ]
    ---Step1: [: check value of tom after it is registered in current task stack ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "tom": "tom created in subtask1",
      "jerry": "this is jerry in global",
      "up_runtime_task_layer_number": 2,
      "john": "john in sub_loop func1"
    })
    
    ~~~SubStep1: [reg: by default hitom is registered in to global context ]
    ~~~SubStep2: [print:  ]
    in sub_loop print1: tom2 created in subtask2
    ---Step2: [: check value of tom and it should be available in current stack ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "up_runtime_task_layer_number": 2,
      "john": "john in sub_loop func2",
      "tom": "tom2 created in subtask2",
      "jerry": "this is jerry in global"
    })
    
    ~~~SubStep1: [print:  ]
    in sub_loop print2: tom2 created in subtask2
    ~~~SubStep2: [return:  ]
    -Step2: [: check value of tom
    in this case tom's value should come from subtask1
    tom's expected value:  tom created in subtask1
     ]
    cranky_franklin4: overall final exec vars:
    
    (*core.Cache)({
      "up_runtime_task_layer_number": 2,
      "tom": "tom created in subtask1",
      "jerry": "this is jerry in global"
    })
    
    ~SubStep1: [print:  ]
    in main task print3: tom created in subtask1
    
```


##### Logs with different verbose level
* [c0114 log - verbose level v](../../logs/c0114_v)
* [c0114 log - verbose level vv](../../logs/c0114_vv)
* [c0114 log - verbose level vvv](../../logs/c0114_vvvv)
* [c0114 log - verbose level vvvv](../../logs/c0114_vvvv)
* [c0114 log - verbose level vvvvv](../../logs/c0114_vvvvv)

##### Raw logs with different verbose level
* [c0114 raw log - verbose level v](../../reflogs/c0114_v.log)
* [c0114 raw log - verbose level vv](../../reflogs/c0114_vv.log)
* [c0114 raw log - verbose level vvv](../../reflogs/c0114_vvv.log)
* [c0114 raw log - verbose level vvvv](../../reflogs/c0114_vvvv.log)
* [c0114 raw log - verbose level vvvvv](../../reflogs/c0114_vvvvv.log)







